---
title: "Part 2: Advanced Recipes & Visual Development"
nav_order: 3
---

# Cursor IDE: Advanced Recipes & Visual Development
## Part 2 of 6: Advanced Techniques and Visual Patterns

**Maintainer**: Viachaslau Kudzinau (viachaslau_kudzinau@epam.com)  
**Version**: 2.0  
**Last Updated**: December 2025

> **üìö Navigation**: [Index](00-index.md) | [‚Üê Part 1](01-cursor-fundamentals.md) | **Part 2** | [Part 3 ‚Üí](03-devops-backend-patterns.md)

---

## Table of Contents

4. [Advanced Recipes](#4-advanced-recipes)
5. [Visual Development Patterns](#5-visual-development-patterns)

---

## 4. Advanced Recipes

### 4.1 API Migration (REST ‚Üí GraphQL)

**Multi-stage prompt:**
```
@instructions.md @api/routes/ @models/

Phase 1: Schema Design
Analyze existing REST endpoints. Design GraphQL schema:
- Types (User, Post, Comment)
- Queries (getUser, listPosts)
- Mutations (createPost, updateUser)
- Relationships (User.posts, Post.comments)

Output schema.graphql
Wait for review.

Phase 2: Resolvers
Generate resolvers for each type. Map to existing service layer:
- @services/userService.ts ‚Üí User resolvers
- @services/postService.ts ‚Üí Post resolvers

Output resolvers/index.ts
Wait for review.

Phase 3: Integration
Update @server.ts:
- Add apollo-server-express
- Mount /graphql endpoint
- Keep REST endpoints (backward compat)

Wait for review.

Phase 4: Tests
Migrate @tests/api/ REST tests to GraphQL queries.
Use supertest + graphql-request.

Run all tests.

Execute phase-by-phase. After each, run tests.
```

### 4.2 Database Schema Migration

**Pattern: Generate + Review**
```
@instructions.md @database/schema.prisma @migrations/

Task: Add soft deletes to User, Post, Comment tables

Steps:
1. Update Prisma schema:
   - Add deletedAt DateTime? to models
   - Add @@index on deletedAt

2. Generate migration:
   - Run `npx prisma migrate dev --name add-soft-deletes`
   - Show SQL diff

3. Update service layer:
   - Modify queries to filter WHERE deletedAt IS NULL
   - Add softDelete() methods
   - Update existing delete calls

4. Update tests:
   - Verify soft-deleted records not returned
   - Test restore functionality
   - Test cascade soft deletes

5. Generate SQL rollback script

Execute step-by-step. Show diffs before applying.
DO NOT run migrations without approval.
```

**Why manual review:** Schema migrations = data risk. Always verify SQL before running.

### 4.3 Large-Scale Refactor (Class ‚Üí Hooks)

**Problem:** 50 React class components ‚Üí functional + hooks

**Strategy: Batch + Template**
```
@instructions.md @components/ @hooks/

Task: Convert class components to functional + hooks

Template:
- State ‚Üí useState
- Lifecycle ‚Üí useEffect
- this.props ‚Üí destructured props
- Class methods ‚Üí useCallback
- Refs ‚Üí useRef

Process:
1. Identify all class components (find `extends React.Component`)
2. Generate conversion plan (list files, complexity estimate)
3. Convert one component per iteration (start with leaf components)
4. After each conversion:
   - Update imports in parent components
   - Run Storybook tests
   - Run Jest snapshots
   - Update snapshots if needed
5. Commit after each successful conversion

Start with leaf components (no children).
Work up the tree to avoid breaking child components.

Generate automation script to track progress.
```

**Automation script (generated by agent):**
```bash
#!/bin/bash
# convert-to-hooks.sh

COMPONENTS=$(find src/components -name '*.tsx' -exec grep -l "extends React.Component" {} \;)

for file in $COMPONENTS; do
  echo "Converting $file..."
  cursor agent "Convert $file to functional component with hooks. Follow template."
  
  npm test -- --testPathPattern="$file"
  if [ $? -eq 0 ]; then
    git add "$file"
    git commit -m "refactor: convert $(basename $file) to hooks"
    echo "‚úì $file converted successfully"
  else
    echo "‚úó $file failed tests - manual intervention needed"
    break
  fi
done

echo "Conversion complete: $(git log --oneline | grep "refactor: convert" | wc -l) components"
```

### 4.4 Dependency Upgrade (Major Version)

**Problem:** React 17 ‚Üí 18 (breaking changes: concurrent rendering, new APIs)

**Prompt:**
```
@instructions.md @package.json @components/ @docs/react-18-migration

Task: Upgrade React 17 ‚Üí 18

Pre-flight:
1. Review breaking changes (@docs)
2. Identify unsafe patterns:
   - ReactDOM.render ‚Üí createRoot
   - Legacy context API
   - Deprecated lifecycle methods
   - Unsafe concurrent rendering patterns

Generate pre-flight report.
Wait for review.

Migration:
1. Update package.json
   - react@18, react-dom@18, @types/react@18
   - Update peer deps (react-query, etc.)

2. Update entry point:
   - Replace ReactDOM.render with createRoot
   - Wrap app in React.StrictMode (if not already)

3. Fix unsafe patterns:
   - Replace componentWillMount with useEffect
   - Update context to use createContext
   - Fix useEffect dependencies (exhaustive-deps lint)

4. Enable Strict Mode features
   - Test for side effects in development
   - Identify double-invocation issues

5. Run test suite:
   - Fix failures (likely async rendering issues)
   - Update snapshots
   - Run E2E tests

6. Performance audit:
   - Profile with React DevTools
   - Check for unnecessary re-renders
   - Verify no performance regressions

Execute step-by-step. Run full test suite after each step.
```

### 4.5 Micro-frontend Integration

**Pattern: Module Federation with Webpack 5**

```
@instructions.md

Task: Set up micro-frontend architecture

Architecture:
- Host app: Main shell (Next.js)
- Remote apps: Dashboard, Settings, Analytics (separate repos)
- Shared: Design system, auth, utils

Tech stack:
- Webpack 5 Module Federation
- React 18
- TypeScript
- Shared state: Zustand

Steps:
1. Configure Module Federation in host app
2. Configure Module Federation in remote apps
3. Create shared library package
4. Set up development environment (all apps running)
5. Implement routing (host manages, remotes register routes)
6. Set up shared authentication
7. Add error boundaries for remote failures

Generate:
- webpack.config.js for host
- webpack.config.js for remotes
- shared/package.json
- docker-compose.yml (dev environment)
- README.md (architecture diagram)
```

---

## 5. Visual Development Patterns (NEW)

### 5.1 Screenshot-Driven Development

**Pattern:** Developers regularly paste UI screenshots into Cursor with high success rates.

**When to use:**
- Designing new UI components
- Fixing UI bugs
- Implementing designs from Figma/other tools
- Replicating layouts from websites

**Workflow:**
```
1. Take screenshot of target UI
2. Paste into Cursor chat
3. Provide context prompt
```

**Example prompt:**
```
[Paste screenshot of v0.dev layout]

Implement this card layout using:
- React + TypeScript
- Tailwind CSS
- shadcn/ui components
- Match spacing, colors, typography exactly
- Make it responsive (mobile-first)
- Add hover states (subtle scale + shadow)

Specific requirements:
- Card width: full width on mobile, max-w-md on desktop
- Image: aspect-ratio-video, object-cover
- Title: text-xl font-semibold
- Description: text-gray-600 text-sm, line-clamp-2
- Button: primary style from shadcn

Generate: components/ProductCard.tsx
```

**Why this works:**
- Vision models excel at layout understanding
- Reduces ambiguity ("make it look good" ‚Üí exact visual reference)
- Faster than describing UI in words
- Can extract exact colors, spacing, typography

**Anti-pattern:** Expecting pixel-perfect reproduction without constraints
**Better:** Specify framework, components, acceptable deviations

### 5.2 Comparative Visual Debugging

**Pattern:** Side-by-side screenshots to identify CSS issues

```
[Screenshot of expected UI]
[Screenshot of actual broken UI]

Compare these. The actual UI has:
- Misaligned buttons (should be right-aligned, currently centered)
- Wrong font size on headers (should be 2xl, appears to be xl)
- Missing border radius on cards (should be rounded-lg)
- Incorrect spacing between items (should be space-y-4, appears to be space-y-2)

Fix the CSS in @components/Card.tsx and @components/Button.tsx
Show me the exact changes needed.
```

**Agent behavior:**
- Analyzes both images
- Identifies exact style discrepancies
- Proposes targeted CSS fixes
- Can apply fixes directly

**Result:** Faster than manually inspecting elements in DevTools.

### 5.3 Visual Editor Workflow (NEW Dec 2025)

**When to use:** Building/debugging UI, need visual feedback

**Workflow:**
```
1. Open Visual Editor (View > Visual Editor)
2. Click on component to inspect
3. Modify styles visually (drag, resize, color picker)
4. Agent generates code changes
5. Apply changes to actual components
```

**Example session:**
```
Visual Editor mode enabled.

Inspecting @components/Hero.tsx:
- Title too small (currently text-3xl)
- CTA button not prominent enough
- Background gradient needs adjustment

Make changes:
1. Title ‚Üí text-5xl font-bold
2. Button ‚Üí larger (h-14 px-8), vibrant color
3. Background ‚Üí darker gradient for contrast

Show me the code changes.
```

**Agent:** Generates exact Tailwind class changes.

### 5.4 Reverse Engineering UIs

**Pattern:** Find UI you like ‚Üí recreate it

```
[Screenshot from Vercel dashboard]

Recreate this dashboard layout:
- Same grid structure (3 columns on desktop, 1 on mobile)
- Same card design (shadow-lg, rounded-xl, border)
- Same color scheme (slate-900 bg, white cards)
- Same data visualization (mini charts in cards)
- Responsive (stack on mobile, grid on desktop)

Tech: Next.js + Tailwind + recharts + shadcn/ui

Don't copy exact implementation - interpret the design system:
- Extract color palette
- Identify spacing scale
- Replicate component hierarchy
- Match interaction patterns

Generate:
- components/Dashboard.tsx (main layout)
- components/StatCard.tsx (reusable card)
- components/MiniChart.tsx (chart component)
- app/dashboard/page.tsx (page)
```

**Legal note:** Only reverse engineer public UIs for learning. Don't copy proprietary designs.

---

## Best Practices Summary

### Advanced Recipes Checklist
- [ ] Break migrations into phases (analysis ‚Üí plan ‚Üí execute)
- [ ] Always generate + review before applying (especially DB migrations)
- [ ] Use automation scripts for batch operations
- [ ] Commit after each successful step
- [ ] Run tests after every change
- [ ] Document breaking changes and rollback plans
- [ ] Maintain backward compatibility when possible

### Visual Development Checklist
- [ ] Use screenshots for exact visual reference
- [ ] Specify tech stack and constraints explicitly
- [ ] Include responsive breakpoints in requirements
- [ ] Define hover/focus states
- [ ] Request specific component structure
- [ ] Use Visual Editor for real-time styling
- [ ] Test across devices/browsers

---

## Next Steps

Continue to [Part 3: DevOps & Backend Patterns ‚Üí](03-devops-backend-patterns.md)

Or return to the [Index](00-index.md) for the complete guide navigation.

---

**Part 2 of 6** | [‚Üê Part 1](01-cursor-fundamentals.md) | [Index](00-index.md) | [Part 3 ‚Üí](03-devops-backend-patterns.md)

